{
  "id": "03-lowest-common-ancestor",
  "title": "Lowest Common Ancestor of a BST",
  "description": "Find the lowest common ancestor (LCA) of two nodes in a binary search tree.",
  "type": "coding",
  "language": "python",
  "difficulty": "intermediate",
  "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    \"\"\"\n    Find the lowest common ancestor (LCA) of two nodes in a BST.\n    \n    The LCA is defined as the lowest node in the tree that has both\n    p and q as descendants (a node can be a descendant of itself).\n    \n    Args:\n        root: The root of the BST\n        p: First node\n        q: Second node\n        \n    Returns:\n        The LCA node of p and q\n        \n    Example:\n        Input: root = [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], p = 2, q = 8\n                    6\n                   / \\\n                  2   8\n                 / \\ / \\\n                0  4 7  9\n                  / \\\n                 3   5\n        Output: 6 (the LCA of nodes 2 and 8)\n        \n        Input: same tree, p = 2, q = 4\n        Output: 2 (node 2 is an ancestor of 4, and itself)\n    \"\"\"\n    # Your code here\n    pass",
  "solutionCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n    current = root\n    \n    while current:\n        if p.val < current.val and q.val < current.val:\n            # Both nodes are in left subtree\n            current = current.left\n        elif p.val > current.val and q.val > current.val:\n            # Both nodes are in right subtree\n            current = current.right\n        else:\n            # Split point - this is the LCA\n            # (one node on each side, or one equals current)\n            return current\n    \n    return None",
  "testCases": [
    {
      "input": {"tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], "p": 2, "q": 8},
      "expected": 6,
      "description": "LCA is root - nodes on different sides"
    },
    {
      "input": {"tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], "p": 2, "q": 4},
      "expected": 2,
      "description": "One node is ancestor of the other"
    },
    {
      "input": {"tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], "p": 0, "q": 5},
      "expected": 2,
      "description": "LCA is internal node"
    },
    {
      "input": {"tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], "p": 3, "q": 5},
      "expected": 4,
      "description": "LCA of siblings"
    },
    {
      "input": {"tree": [2, 1], "p": 2, "q": 1},
      "expected": 2,
      "description": "Two node tree"
    },
    {
      "input": {"tree": [6, 2, 8, 0, 4, 7, 9, null, null, 3, 5], "p": 7, "q": 9},
      "expected": 8,
      "description": "LCA in right subtree"
    }
  ],
  "hints": [
    "Use the BST property: all left descendants are smaller, all right descendants are larger",
    "The LCA is where the paths to p and q diverge (one goes left, one goes right)",
    "If both p and q are smaller than current node, LCA must be in left subtree",
    "If both p and q are greater than current node, LCA must be in right subtree",
    "Otherwise, current node is the split point (the LCA)"
  ],
  "explanation": "In a BST, we can efficiently find the LCA by leveraging the ordering property. Starting from the root, we compare both target values with the current node. If both values are smaller, the LCA must be in the left subtree. If both are larger, it must be in the right subtree. When the values split (one smaller, one larger, or one equals current), we have found the LCA - this is where the paths to p and q diverge. Time complexity is O(h) where h is the tree height, and space complexity is O(1) for the iterative solution."
}
