{
  "id": "01-inorder-traversal",
  "title": "Binary Tree Inorder Traversal",
  "description": "Implement an in-order traversal of a binary tree, returning the values in sorted order for a BST.",
  "type": "coding",
  "language": "python",
  "difficulty": "beginner",
  "starterCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef inorder_traversal(root: TreeNode) -> list[int]:\n    \"\"\"\n    Perform an in-order traversal of a binary tree.\n    \n    In-order traversal visits nodes in the order:\n    Left subtree -> Current node -> Right subtree\n    \n    Args:\n        root: The root of the binary tree\n        \n    Returns:\n        A list of values in in-order sequence\n        \n    Example:\n        Input: root = [1, null, 2, 3]\n               1\n                \\\n                 2\n                /\n               3\n        Output: [1, 3, 2]\n    \"\"\"\n    # Your code here\n    pass",
  "solutionCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef inorder_traversal(root: TreeNode) -> list[int]:\n    result = []\n    \n    def inorder(node):\n        if node is None:\n            return\n        inorder(node.left)\n        result.append(node.val)\n        inorder(node.right)\n    \n    inorder(root)\n    return result",
  "testCases": [
    {
      "input": {"tree": [1, null, 2, 3]},
      "expected": [1, 3, 2],
      "description": "Right-skewed tree with left child"
    },
    {
      "input": {"tree": []},
      "expected": [],
      "description": "Empty tree"
    },
    {
      "input": {"tree": [1]},
      "expected": [1],
      "description": "Single node"
    },
    {
      "input": {"tree": [4, 2, 6, 1, 3, 5, 7]},
      "expected": [1, 2, 3, 4, 5, 6, 7],
      "description": "Complete BST returns sorted order"
    },
    {
      "input": {"tree": [3, 1, 4, null, 2]},
      "expected": [1, 2, 3, 4],
      "description": "Unbalanced tree"
    }
  ],
  "hints": [
    "Think about the order: left subtree first, then current node, then right subtree",
    "Use recursion to naturally traverse the tree structure",
    "For an iterative solution, use a stack to track nodes to visit",
    "The base case for recursion is when the node is None"
  ],
  "explanation": "In-order traversal follows the pattern: Left -> Node -> Right. For each node, we first recursively visit its entire left subtree, then process the current node, and finally visit its right subtree. This order is particularly useful for BSTs because it visits nodes in sorted order. The recursive solution is elegant: if the node is None, return; otherwise, recurse left, add current value, and recurse right. Time complexity is O(n) where n is the number of nodes, and space complexity is O(h) where h is the tree height due to the recursion stack."
}
