{
  "id": "02-merge-k-sorted-lists",
  "title": "Merge K Sorted Lists",
  "description": "Merge k sorted linked lists into one sorted linked list using a heap.",
  "type": "coding",
  "language": "python",
  "difficulty": "intermediate",
  "starterCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef merge_k_lists(lists: list) -> ListNode:\n    \"\"\"\n    Merge k sorted linked lists into one sorted linked list.\n    \n    Args:\n        lists: Array of k linked-lists, each sorted in ascending order\n        \n    Returns:\n        The merged sorted linked list\n        \n    Example:\n        Input: lists = [[1,4,5], [1,3,4], [2,6]]\n        Output: [1,1,2,3,4,4,5,6]\n        Explanation: Merge three sorted lists into one sorted list.\n        \n        Input: lists = []\n        Output: []\n        \n        Input: lists = [[]]\n        Output: []\n    \"\"\"\n    # Your code here\n    pass",
  "solutionCode": "import heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\ndef merge_k_lists(lists: list) -> ListNode:\n    # Handle edge cases\n    if not lists:\n        return None\n    \n    # Min-heap: (value, list_index, node)\n    # We use list_index as tiebreaker since nodes aren't comparable\n    heap = []\n    \n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n    \n    dummy = ListNode(0)\n    current = dummy\n    \n    while heap:\n        val, i, node = heapq.heappop(heap)\n        current.next = node\n        current = current.next\n        \n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n    \n    return dummy.next",
  "testCases": [
    {
      "input": {"lists": [[1, 4, 5], [1, 3, 4], [2, 6]]},
      "expected": [1, 1, 2, 3, 4, 4, 5, 6],
      "description": "Three sorted lists"
    },
    {
      "input": {"lists": []},
      "expected": [],
      "description": "Empty input"
    },
    {
      "input": {"lists": [[]]},
      "expected": [],
      "description": "Single empty list"
    },
    {
      "input": {"lists": [[1], [2], [3]]},
      "expected": [1, 2, 3],
      "description": "Single element lists"
    },
    {
      "input": {"lists": [[1, 2, 3]]},
      "expected": [1, 2, 3],
      "description": "Single list"
    },
    {
      "input": {"lists": [[5, 6, 7], [1, 2, 3], [4]]},
      "expected": [1, 2, 3, 4, 5, 6, 7],
      "description": "Non-overlapping ranges"
    }
  ],
  "hints": [
    "Use a min-heap to track the smallest unprocessed node across all lists",
    "Initialize the heap with the first node from each non-empty list",
    "When you pop a node, push its next node (if exists) to the heap",
    "Use an index to break ties when nodes have equal values",
    "A dummy head node simplifies the list construction"
  ],
  "explanation": "We use a min-heap to efficiently get the smallest element among all list heads. Initialize the heap with the head of each non-empty list. Repeatedly extract the minimum, add it to the result, and push the next node from that list if it exists. Using (value, list_index, node) tuples ensures proper ordering even with equal values. Time complexity is O(n log k) where n is total nodes and k is number of lists. Space complexity is O(k) for the heap."
}
